# AWS Infrastructure for Company.WebApplication1
# This file is generated by NDC and creates cloud services based on your local configuration

locals {
  app_name = "Company.WebApplication1"
  service_name = lower(replace(local.app_name, ".", "-"))
  
  # Service configuration discovery
  has_database = var.include_database
  has_cache = var.include_cache  
  has_storage = var.include_storage
  has_queue = var.include_queue
}

# Data sources
data "aws_caller_identity" "current" {}
data "aws_region" "current" {}

#
# Container Registry (ECR)
#
resource "aws_ecr_repository" "app" {
  name                 = "${local.service_name}"
  image_tag_mutability = "MUTABLE"

  image_scanning_configuration {
    scan_on_push = true
  }

  lifecycle_policy {
    policy = jsonencode({
      rules = [
        {
          rulePriority = 1
          description  = "Keep last 10 production images"
          selection = {
            tagStatus     = "tagged"
            tagPrefixList = ["v"]
            countType     = "imageCountMoreThan"
            countNumber   = 10
          }
          action = {
            type = "expire"
          }
        },
        {
          rulePriority = 2
          description  = "Keep last 3 untagged images"
          selection = {
            tagStatus   = "untagged"
            countType   = "imageCountMoreThan"
            countNumber = 3
          }
          action = {
            type = "expire"
          }
        }
      ]
    })
  }

  tags = {
    Name        = local.service_name
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}

#
# Database (RDS) - Conditional
#
#if (HasDatabase)
resource "aws_db_subnet_group" "app" {
  count = local.has_database ? 1 : 0
  
  name       = "${local.service_name}-db-subnet-group"
  subnet_ids = var.database_subnet_ids

  tags = {
    Name        = "${local.service_name}-db-subnet-group"
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}

resource "aws_security_group" "database" {
  count = local.has_database ? 1 : 0
  
  name_prefix = "${local.service_name}-db-"
  vpc_id      = var.vpc_id

  ingress {
    from_port   = var.database_port
    to_port     = var.database_port
    protocol    = "tcp"
    cidr_blocks = [var.vpc_cidr]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name        = "${local.service_name}-database-sg"
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}

#if (UsePostgreSQL)
resource "aws_db_instance" "postgres" {
  count = local.has_database && var.database_type == "PostgreSQL" ? 1 : 0
  
  identifier             = "${local.service_name}-postgres"
  engine                 = "postgres"
  engine_version        = var.postgres_version
  instance_class        = var.database_instance_class
  allocated_storage     = var.database_allocated_storage
  storage_encrypted     = true
  
  db_name  = replace(local.app_name, ".", "")
  username = var.database_username
  password = var.database_password
  
  vpc_security_group_ids = [aws_security_group.database[0].id]
  db_subnet_group_name   = aws_db_subnet_group.app[0].name
  
  backup_retention_period = var.environment == "production" ? 7 : 1
  backup_window          = "03:00-04:00"
  maintenance_window     = "sun:04:00-sun:05:00"
  
  skip_final_snapshot = var.environment != "production"
  deletion_protection = var.environment == "production"

  tags = {
    Name        = "${local.service_name}-postgres"
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}
#endif

#if (UseMySQL)
resource "aws_db_instance" "mysql" {
  count = local.has_database && var.database_type == "MySQL" ? 1 : 0
  
  identifier             = "${local.service_name}-mysql"
  engine                 = "mysql"
  engine_version        = var.mysql_version
  instance_class        = var.database_instance_class
  allocated_storage     = var.database_allocated_storage
  storage_encrypted     = true
  
  db_name  = replace(local.app_name, ".", "")
  username = var.database_username
  password = var.database_password
  
  vpc_security_group_ids = [aws_security_group.database[0].id]
  db_subnet_group_name   = aws_db_subnet_group.app[0].name
  
  backup_retention_period = var.environment == "production" ? 7 : 1
  backup_window          = "03:00-04:00"
  maintenance_window     = "sun:04:00-sun:05:00"
  
  skip_final_snapshot = var.environment != "production"
  deletion_protection = var.environment == "production"

  tags = {
    Name        = "${local.service_name}-mysql"
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}
#endif
#endif

#
# Cache (ElastiCache) - Conditional
#
#if (IncludeCache)
resource "aws_elasticache_subnet_group" "app" {
  count = local.has_cache ? 1 : 0
  
  name       = "${local.service_name}-cache-subnet-group"
  subnet_ids = var.cache_subnet_ids
}

resource "aws_security_group" "cache" {
  count = local.has_cache ? 1 : 0
  
  name_prefix = "${local.service_name}-cache-"
  vpc_id      = var.vpc_id

  ingress {
    from_port   = 6379
    to_port     = 6379
    protocol    = "tcp"
    cidr_blocks = [var.vpc_cidr]
  }

  tags = {
    Name        = "${local.service_name}-cache-sg"
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}

resource "aws_elasticache_cluster" "redis" {
  count = local.has_cache ? 1 : 0
  
  cluster_id           = "${local.service_name}-redis"
  engine              = "redis"
  node_type           = var.cache_node_type
  num_cache_nodes     = 1
  parameter_group_name = "default.redis7"
  port                = 6379
  subnet_group_name   = aws_elasticache_subnet_group.app[0].name
  security_group_ids  = [aws_security_group.cache[0].id]

  tags = {
    Name        = "${local.service_name}-redis"
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}
#endif

#
# Storage (S3)
#
#if (IncludeStorage)
resource "aws_s3_bucket" "app" {
  count = local.has_storage ? 1 : 0
  
  bucket = "${local.service_name}-${var.environment}-storage"

  tags = {
    Name        = "${local.service_name}-storage"
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}

resource "aws_s3_bucket_public_access_block" "app" {
  count = local.has_storage ? 1 : 0
  
  bucket = aws_s3_bucket.app[0].id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

resource "aws_s3_bucket_server_side_encryption_configuration" "app" {
  count = local.has_storage ? 1 : 0
  
  bucket = aws_s3_bucket.app[0].id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

resource "aws_s3_bucket_versioning" "app" {
  count = local.has_storage ? 1 : 0
  
  bucket = aws_s3_bucket.app[0].id
  
  versioning_configuration {
    status = var.environment == "production" ? "Enabled" : "Suspended"
  }
}
#endif

#
# Message Queue (SQS) - Conditional  
#
#if (IncludeQueue)
resource "aws_sqs_queue" "app" {
  count = local.has_queue ? 1 : 0
  
  name                      = "${local.service_name}-queue"
  delay_seconds             = 0
  max_message_size          = 262144
  message_retention_seconds = 1209600
  receive_wait_time_seconds = 10
  visibility_timeout_seconds = 300

  tags = {
    Name        = "${local.service_name}-queue"
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}

resource "aws_sqs_queue" "app_dlq" {
  count = local.has_queue ? 1 : 0
  
  name = "${local.service_name}-dlq"

  tags = {
    Name        = "${local.service_name}-dlq"
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}
#endif

#
# IAM Role for App Runner
#
data "aws_iam_policy_document" "apprunner_trust" {
  statement {
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["build.apprunner.amazonaws.com", "tasks.apprunner.amazonaws.com"]
    }
  }
}

resource "aws_iam_role" "apprunner" {
  name               = "${local.service_name}-apprunner-role"
  assume_role_policy = data.aws_iam_policy_document.apprunner_trust.json

  tags = {
    Name        = "${local.service_name}-apprunner-role"
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}

resource "aws_iam_role_policy_attachment" "apprunner_ecr" {
  role       = aws_iam_role.apprunner.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSAppRunnerServicePolicyForECRAccess"
}

# Additional permissions for cloud services
data "aws_iam_policy_document" "apprunner_permissions" {
  statement {
    actions = [
      "ecr:GetAuthorizationToken",
      "ecr:BatchCheckLayerAvailability",
      "ecr:GetDownloadUrlForLayer",
      "ecr:BatchGetImage"
    ]
    resources = ["*"]
  }

#if (IncludeStorage)
  dynamic "statement" {
    for_each = local.has_storage ? [1] : []
    content {
      actions = [
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject"
      ]
      resources = ["${aws_s3_bucket.app[0].arn}/*"]
    }
  }

  dynamic "statement" {
    for_each = local.has_storage ? [1] : []
    content {
      actions = ["s3:ListBucket"]
      resources = [aws_s3_bucket.app[0].arn]
    }
  }
#endif

#if (IncludeQueue)
  dynamic "statement" {
    for_each = local.has_queue ? [1] : []
    content {
      actions = [
        "sqs:SendMessage",
        "sqs:ReceiveMessage",
        "sqs:DeleteMessage",
        "sqs:GetQueueAttributes"
      ]
      resources = [aws_sqs_queue.app[0].arn]
    }
  }
#endif

#if (IncludeMail)
  statement {
    actions = [
      "ses:SendEmail",
      "ses:SendRawEmail"
    ]
    resources = ["*"]
  }
#endif
}

resource "aws_iam_role_policy" "apprunner_permissions" {
  name   = "${local.service_name}-apprunner-permissions"
  role   = aws_iam_role.apprunner.id
  policy = data.aws_iam_policy_document.apprunner_permissions.json
}

#
# App Runner Service
#
resource "aws_apprunner_service" "app" {
  service_name = local.service_name

  source_configuration {
    image_repository {
      image_identifier      = "${data.aws_caller_identity.current.account_id}.dkr.ecr.${data.aws_region.current.name}.amazonaws.com/${aws_ecr_repository.app.name}:latest"
      image_repository_type = "ECR"
      
      image_configuration {
        port = var.port.toString()
        
        # Environment variables for cloud services
        runtime_environment_variables = merge(
          {
            ASPNETCORE_ENVIRONMENT = "Production"
            ASPNETCORE_URLS = "http://+:Port"
#if (HasDatabase)
#if (UsePostgreSQL)
            ConnectionStrings__Database = local.has_database ? "Host=${aws_db_instance.postgres[0].endpoint};Port=${aws_db_instance.postgres[0].port};Database=${aws_db_instance.postgres[0].db_name};Username=${var.database_username};Password=${var.database_password}" : ""
#endif
#if (UseMySQL)  
            ConnectionStrings__Database = local.has_database ? "Server=${aws_db_instance.mysql[0].endpoint};Port=${aws_db_instance.mysql[0].port};Database=${aws_db_instance.mysql[0].db_name};Uid=${var.database_username};Pwd=${var.database_password};" : ""
#endif
#endif
#if (IncludeCache)
            ConnectionStrings__Redis = local.has_cache ? "${aws_elasticache_cluster.redis[0].cache_nodes[0].address}:${aws_elasticache_cluster.redis[0].cache_nodes[0].port}" : ""
#endif
#if (IncludeStorage)
            S3__BucketName = local.has_storage ? aws_s3_bucket.app[0].bucket : ""
            S3__Region = data.aws_region.current.name
#endif
#if (IncludeQueue)
            MessageQueue__SQSQueueUrl = local.has_queue ? aws_sqs_queue.app[0].url : ""
#endif
          },
          var.additional_environment_variables
        )
      }
    }

    authentication_configuration {
      access_role_arn = aws_iam_role.apprunner.arn
    }

    auto_deployments_enabled = var.auto_deployments_enabled
  }

  instance_configuration {
    cpu               = var.cpu
    memory            = var.memory
    instance_role_arn = aws_iam_role.apprunner.arn
  }

  health_check_configuration {
    protocol            = "HTTP"
    path                = "/health"
    interval            = 10
    timeout             = 5
    healthy_threshold   = 1
    unhealthy_threshold = 3
  }

  auto_scaling_configuration_arn = aws_apprunner_auto_scaling_configuration_version.app.arn

  tags = {
    Name        = local.service_name
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}

resource "aws_apprunner_auto_scaling_configuration_version" "app" {
  auto_scaling_configuration_name = "${local.service_name}-autoscaling"
  
  max_concurrency = var.max_concurrency
  min_size        = var.min_instances
  max_size        = var.max_instances

  tags = {
    Name        = "${local.service_name}-autoscaling"
    Environment = var.environment
    ManagedBy   = "ndc"
  }
}